<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.task_controller API documentation</title>
<meta name="description" content="Created on Tue Jun
1 21:39:56 2021 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.task_controller</code></h1>
</header>
<section id="section-intro">
<p>Created on Tue Jun
1 21:39:56 2021</p>
<p>@author: dsubhasish</p>
<p>The class defined here can be used as a template for writing code for more
complex task space controllers. Currently no constraints have been applied.
This will be changed in future versions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Tue Jun  1 21:39:56 2021

@author: dsubhasish

The class defined here can be used as a template for writing code for more 
complex task space controllers. Currently no constraints have been applied. 
This will be changed in future versions.
&#34;&#34;&#34;
import numpy as np
import rospy
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from control_func import *
import pickle
import time
import matplotlib.pyplot as plt

class Task_Controller(object):
    &#34;&#34;&#34;A bare bones implementation of a task space controller
    
    This controller object receives current joint state messages from 
    /manipulator/joint_states topic and the desired task space trajectory from 
    the /task_desired topic. It then computes the command torque and sends it
    to Gazebo through the /manipulator/group_effort_controller/command topic.

    Attributes
    ----------
    joint_state : JointState
        Current joint state received from Gazebo.
    theta : np.ndarray of shape (6,1)
        Current joint angle vector.
    dtheta : np.ndarray of shape (6,1)
        Current joint velocity vector
    traj_sub : rospy.Subscriber
        Subscriber of desired joint trajectory topic (/task_desired).
    joint_state_sub : rospy.Subscriber
        Subscriber of current joint state topic (/manipulator/joint_states).
    torque_pub : rospy.Publisher
        Publisher of computed command torque to the /manipulator/group_effort_controller/command topic.
    Kp : float
        Kp gain.
    Kd : float
        Kd gain.
    phis : np.ndarray of shape (6,6,6)
        array of Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
        phi_i-1_i for i=1 to 6. 
    phis_l : int
        Frequency at which to publish command torque. Reciprocal of control sampling interval
    cphis : numpy.ndarray of shape (6,6,6)
        array of Cummulative Rigid body transformation matrices. cphis[0] to cphis[5] are the cummulative rigid body transformation matrices
        phi_i-1_6 for i=1 to 6. 
    task_spatial_pos : np.ndarray of shape (6,1)
        Current task space position
    task_spatial_vel : np.ndarray of shape (6,1)
        Current task space velocity
    Ja_ : np.ndarray of shape (6,6)
        Regularized analytic jacobian
    Ja_inv : np.ndarray of shape (6,6)
        Jacobian pseudo inverse
    Ja : np.ndarray of shape (6,6)
        Unregularized analytic jacobian
    Jad : np.ndarray of shape (6,6)
        Time derivative of analytic jacobian
    f : float
        Torque publishing frequency
    Xd : np.ndarray of shape (6,1)
        Desired task space position
    dXd : np.ndarray of shape (6,1)
        Desired task space velocity
    ddXd : np.ndarray of shape (6,1)
        Desired task space acceleration
    Tc : np.ndarray of shape (6,1)
        Command torque
    msg : Float64MultiArray
        Torque message to be published
    D : np.ndarray of shape (6,6)
        Joint Space Inertia Matrix
    CG : np.ndarray of shape (6,1)
        Vector of centrifugal, coriolis and gravity forces
    Bt : np.ndarray of shape (6,1)
        Task to be performed
    qdd : np.ndarray of shape (6,1)
        Commanded joint space acceleration
    V : list
        list of spatial velocities
    A : list
        list of spatial accelerations
    g : list
        list of spatial gravity
    &#34;&#34;&#34;
    
    def __init__(self,Kp=100,Kd=20,f=200):
        &#34;&#34;&#34;
        Parameters
        ----------
        Kp : TYPE, float
             The default is 100.
        Kd : TYPE, float
             The default is 20.
        f : TYPE, float
             The default is 200.Frequency at which to publish torque
        &#34;&#34;&#34;
        
        self.Kp=Kp
        self.Kd=Kd
        self.joint_state=JointState()#stores joint state message
        #setting initial values
        self.joint_state.position=6*[0]
        self.joint_state.velocity=6*[0]
        #joint state subscriber
        self.joint_state_sub=rospy.Subscriber(&#39;/manipulator/joint_states&#39;, JointState, self.update_state,queue_size=1) #subscriber for joint state
        self.theta=np.zeros((6,1))#current joint angle
        self.dtheta=np.zeros((6,1))#current joint velocity
        self.phis=np.zeros((6,6,6))#rigid body transformation matrix
        self.phis_l=np.zeros((6,6,6))#link rigid body transformation matrix
        self.cphis=np.zeros((6,6,6))#cummulative rigid body transformation matrix
        self.task_spatial_pos=np.zeros((6,1))#current task space coordinate
        self.task_spatial_vel=np.zeros((6,1))#current task space velocity
        #for storing jacobians and jacobian derivatives
        self.Ja_=np.zeros((6,6))
        self.Ja_inv=np.zeros((6,6))
        self.Ja=np.zeros((6,6))
        self.Jad=np.zeros((6,6))
        
        self.f=f#torque publishing frequency
        
        #initial desired task space coordinate, task space velocity and task space acceleration
        theta=np.array([[0,pi/3,-pi/2,0,pi/3,0]]).T
        self.Xd=joint2task(theta)
        self.dXd=np.zeros((6,1))
        self.ddXd=np.zeros((6,1))

        self.Tc=np.zeros((6,1))#computed joint torque
        #torque publisher
        self.torque_pub=rospy.Publisher(&#39;/manipulator/group_effort_controller/command&#39;,Float64MultiArray,queue_size=1,latch=True)#command torque publisher
        self.msg=Float64MultiArray()#torque message to be published
        
        #matrices used for command torque computation
        self.D=np.zeros((6,6))
        self.CG=np.zeros((6,1))
        self.Bt=np.zeros((6,1))
        self.qdd=np.zeros((6,1))
        self.V=6*[np.zeros((6,1))]
        self.A=6*[np.zeros((6,1))]
        self.g=6*[np.zeros((6,1))]
        
        #subscriber for desired task space trajectory
        self.traj_sub=rospy.Subscriber(&#39;/task_desired&#39;, Float64MultiArray, self.update_desired_task,queue_size=1) #subscribing to /theta_desired
        

    def update_state(self,msg):
        &#34;&#34;&#34;
        Call back function for joint state subscriber. Updates self.theta and self.thetad whenever a new joint state message is received

        Parameters
        ----------
        msg : JointState
             Message received on /hhumanoid/joint_states

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.joint_state.position=msg.position
        self.joint_state.velocity=msg.velocity
        self.joint_state.header=msg.header
        
    def update_desired_task(self,msg):
        &#34;&#34;&#34;
        Call back function for desired task space trajectory topic. Updates corresponding values 
        for command torque computation

        Parameters
        ----------
        msg : Float64MultiArray
             message within the desired task space trajectory topic

        Returns
        -------
        None.

        &#34;&#34;&#34;
        traj=msg.data
        self.Xd[0:6,0]=traj[0:6]
        self.dXd[0:6,0]=traj[6:12]
        self.ddXd[0:6,0]=traj[12:18]

    def compute_torque(self):
        &#34;&#34;&#34;
        Carries out one iteration of command torque computation.
        
        Takes current joint space position and velocity, uses it to get the rigid 
        body transformation matrices and calculate the Analytical Jacobian and its 
        time derivative. The Jacobian matrix is then regularized and its pseudo-
        inverse is taken.The required task to be performed is then computed, and 
        using the pseudo inverse of the Jacobian, the required joint space acceleration
        is obtained. The command torque is finally obtained by means of inverse 
        dynamics.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        #get current joint state and joint velocity
        self.theta[0:6,0],self.dtheta[0:6,0]=self.joint_state.position[0:6],self.joint_state.velocity[0:6]
        #get rigid body transformation matrices and cumulative rigid body transformation matrices
        self.phis[:,:,:],self.phis_l[:,:,:],_=get_phi(alpha,a,theta0,self.theta,d,a0,alpha0)
        self.cphis[:,:,:]=get_cummulative_phi(self.phis)
        #rigid body transformation from base frame to end effector frame
        ef=self.cphis[0,:,:] @ phi6_ef
        #get current task space coordinate
        self.task_spatial_pos[0:3]=np.array(euler_from_matrix(ef[0:3,0:3],&#39;rzyz&#39;)).reshape((3,1))
        self.task_spatial_pos[3:6]=pos_from_phi(ef)
        euler=self.task_spatial_pos[0:3]#get current euler angle
        Ta_inv=geometric2analytic_jacobian(euler)#matrix to be premultiplied with geometric jacobian
        J,J_,R06=geometric_jacobian(self.cphis)#get geometric jacobian
        self.Ja_[:,:]=np.matmul(Ta_inv,J)#analytical jacobian

        self.Ja[:,:]=self.Ja_[:,:]#to separate from regularized analytical jacobian

        self.task_spatial_vel[:,:]=np.matmul(self.Ja,self.dtheta)#current task space velocity
        Jd=dJ_dt(J_,R06,self.phis,self.phis_l,self.cphis,self.theta,self.dtheta,6)#derivative of geometric jacobian
        deuler=self.task_spatial_vel[0:3]#euler angle rate
        dte=dTe(euler,deuler)
        self.Jad[:,:]=Ta_inv @ (Jd-dte @ self.Ja)#derivative of analytical jacobian
        
        self.Ja_[:,:],self.Ja_inv[:,:]=self.regularize(self.Ja,100)#regularize
        err=self.state_difference(self.Xd,self.task_spatial_pos)#error

        derr=self.dXd-self.task_spatial_vel#derivative error
        #command torque computation
        self.Bt[:,:]=self.ddXd+self.Kd * derr +self.Kp * err-np.matmul(self.Jad,self.dtheta)
        self.qdd[:,:]=self.Ja_inv @ self.Bt+(np.eye(6)-(self.Ja_inv @ self.Ja_)) @ (100-self.theta+20-self.dtheta)
        self.D[:,:]=compute_D(SMs, self.phis,H)
        self.V[:],self.A[:],self.g[:]=forward_sweep(theta0,self.theta,self.dtheta,self.phis,H)
        self.CG[:,:]= reverse_sweep(self.phis,SMs,m,self.V,self.A,self.g,H,COMs)
        self.Tc[:,:]= self.D @ self.qdd +self.CG

    def regularize(self,A,cond):
        &#34;&#34;&#34;
        regularizes input matrix A using a modified truncated SVD regularization using
        cond as the threshold condition number

        Parameters
        ----------
        A : numpy.ndarray
             input matrix
        cond : float
             threshold condition number

        Returns
        -------
        A_ : numpy.ndarray
             regularized matrix
        A_pinv: numpy.ndarray
            pseudo inverse of regularized matrix

        &#34;&#34;&#34;
        U,S,Vt=np.linalg.svd(A)

        S=S[S[0]/S&lt;cond]

        S_=np.diag(S)
        n=len(S)
        A_=np.matmul(U[:,0:n],np.matmul(S_,Vt[0:n,:]))#regularized matrix

        S1=1/S
        S1_=np.diag(S1)
        A_pinv=np.matmul(Vt[0:n,:].T,np.matmul(S1_,U[:,0:n].T))
        return A_,A_pinv


    def state_difference(self,Xg,Xs):
        &#34;&#34;&#34;
        The function which gives the difference between task space coordinates
        Xg and Xs as per the Euler Angle based scheme.

        Parameters
        ----------
        Xg : numpy.ndarray
             goal task space coordinate/desired task space coordinate
        Xs : numpy.ndarray
             start task space coordinate/current task space coordinate

        Returns
        -------
        Xd : numpy.ndarray
             difference between task space coordinates Xg and Xs as per the control scheme.

        &#34;&#34;&#34;
        Xd=Xg-Xs
        Xde=Xd[0:3]
        #converting angles greater than pi to equivalent negative angle
        #done so that the difference indicates the shortest possible path
        idx=np.abs(Xde)&gt;pi
        Xde[idx]=-np.sign(Xde[idx])*(2*pi-np.abs(Xde[idx]))
        Xd[0:3,0]=Xde[0:3,0]
        return Xd

    def control_loop(self):
        &#34;&#34;&#34;
        Carries out one iteration of torque computation, followed by publishing
        the torque to /manipulator/group_effort_controller/command.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        r=rospy.Rate(self.f)

        while not rospy.is_shutdown():
            self.compute_torque()#compute torque
            self.msg.data=self.Tc[:]#message to be published
            try:

                self.torque_pub.publish(self.msg)#publish
                r.sleep()
            except:
                break
    
    def get_time(self):
        &#34;&#34;&#34;
        helper function to get current time from the joint state

        Returns
        -------
        t : float
             current time

        &#34;&#34;&#34;
        header=self.joint_state.header
        t=header.stamp.secs+header.stamp.nsecs*10**-9
        return t
 
if __name__ == &#39;__main__&#39;:
    rospy.init_node(&#39;torque_commander&#39;)#start node
    task=Task_Controller()#initialize controller
    task.control_loop()#start torque computation loop</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.task_controller.Task_Controller"><code class="flex name class">
<span>class <span class="ident">Task_Controller</span></span>
<span>(</span><span>Kp=100, Kd=20, f=200)</span>
</code></dt>
<dd>
<div class="desc"><p>A bare bones implementation of a task space controller</p>
<p>This controller object receives current joint state messages from
/manipulator/joint_states topic and the desired task space trajectory from
the /task_desired topic. It then computes the command torque and sends it
to Gazebo through the /manipulator/group_effort_controller/command topic.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>joint_state</code></strong> :&ensp;<code>JointState</code></dt>
<dd>Current joint state received from Gazebo.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Current joint angle vector.</dd>
<dt><strong><code>dtheta</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Current joint velocity vector</dd>
<dt><strong><code>traj_sub</code></strong> :&ensp;<code>rospy.Subscriber</code></dt>
<dd>Subscriber of desired joint trajectory topic (/task_desired).</dd>
<dt><strong><code>joint_state_sub</code></strong> :&ensp;<code>rospy.Subscriber</code></dt>
<dd>Subscriber of current joint state topic (/manipulator/joint_states).</dd>
<dt><strong><code>torque_pub</code></strong> :&ensp;<code>rospy.Publisher</code></dt>
<dd>Publisher of computed command torque to the /manipulator/group_effort_controller/command topic.</dd>
<dt><strong><code>Kp</code></strong> :&ensp;<code>float</code></dt>
<dd>Kp gain.</dd>
<dt><strong><code>Kd</code></strong> :&ensp;<code>float</code></dt>
<dd>Kd gain.</dd>
<dt><strong><code>phis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array of Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
phi_i-1_i for i=1 to 6.</dd>
<dt><strong><code>phis_l</code></strong> :&ensp;<code>int</code></dt>
<dd>Frequency at which to publish command torque. Reciprocal of control sampling interval</dd>
<dt><strong><code>cphis</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array of Cummulative Rigid body transformation matrices. cphis[0] to cphis[5] are the cummulative rigid body transformation matrices
phi_i-1_6 for i=1 to 6.</dd>
<dt><strong><code>task_spatial_pos</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Current task space position</dd>
<dt><strong><code>task_spatial_vel</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Current task space velocity</dd>
<dt><strong><code>Ja_</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>Regularized analytic jacobian</dd>
<dt><strong><code>Ja_inv</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>Jacobian pseudo inverse</dd>
<dt><strong><code>Ja</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>Unregularized analytic jacobian</dd>
<dt><strong><code>Jad</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>Time derivative of analytic jacobian</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>float</code></dt>
<dd>Torque publishing frequency</dd>
<dt><strong><code>Xd</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Desired task space position</dd>
<dt><strong><code>dXd</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Desired task space velocity</dd>
<dt><strong><code>ddXd</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Desired task space acceleration</dd>
<dt><strong><code>Tc</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Command torque</dd>
<dt><strong><code>msg</code></strong> :&ensp;<code>Float64MultiArray</code></dt>
<dd>Torque message to be published</dd>
<dt><strong><code>D</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>Joint Space Inertia Matrix</dd>
<dt><strong><code>CG</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Vector of centrifugal, coriolis and gravity forces</dd>
<dt><strong><code>Bt</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Task to be performed</dd>
<dt><strong><code>qdd</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Commanded joint space acceleration</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>list</code></dt>
<dd>list of spatial velocities</dd>
<dt><strong><code>A</code></strong> :&ensp;<code>list</code></dt>
<dd>list of spatial accelerations</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>list</code></dt>
<dd>list of spatial gravity</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Kp</code></strong> :&ensp;<code>TYPE, float</code></dt>
<dd>The default is 100.</dd>
<dt><strong><code>Kd</code></strong> :&ensp;<code>TYPE, float</code></dt>
<dd>The default is 20.</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>TYPE, float</code></dt>
<dd>The default is 200.Frequency at which to publish torque</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Task_Controller(object):
    &#34;&#34;&#34;A bare bones implementation of a task space controller
    
    This controller object receives current joint state messages from 
    /manipulator/joint_states topic and the desired task space trajectory from 
    the /task_desired topic. It then computes the command torque and sends it
    to Gazebo through the /manipulator/group_effort_controller/command topic.

    Attributes
    ----------
    joint_state : JointState
        Current joint state received from Gazebo.
    theta : np.ndarray of shape (6,1)
        Current joint angle vector.
    dtheta : np.ndarray of shape (6,1)
        Current joint velocity vector
    traj_sub : rospy.Subscriber
        Subscriber of desired joint trajectory topic (/task_desired).
    joint_state_sub : rospy.Subscriber
        Subscriber of current joint state topic (/manipulator/joint_states).
    torque_pub : rospy.Publisher
        Publisher of computed command torque to the /manipulator/group_effort_controller/command topic.
    Kp : float
        Kp gain.
    Kd : float
        Kd gain.
    phis : np.ndarray of shape (6,6,6)
        array of Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
        phi_i-1_i for i=1 to 6. 
    phis_l : int
        Frequency at which to publish command torque. Reciprocal of control sampling interval
    cphis : numpy.ndarray of shape (6,6,6)
        array of Cummulative Rigid body transformation matrices. cphis[0] to cphis[5] are the cummulative rigid body transformation matrices
        phi_i-1_6 for i=1 to 6. 
    task_spatial_pos : np.ndarray of shape (6,1)
        Current task space position
    task_spatial_vel : np.ndarray of shape (6,1)
        Current task space velocity
    Ja_ : np.ndarray of shape (6,6)
        Regularized analytic jacobian
    Ja_inv : np.ndarray of shape (6,6)
        Jacobian pseudo inverse
    Ja : np.ndarray of shape (6,6)
        Unregularized analytic jacobian
    Jad : np.ndarray of shape (6,6)
        Time derivative of analytic jacobian
    f : float
        Torque publishing frequency
    Xd : np.ndarray of shape (6,1)
        Desired task space position
    dXd : np.ndarray of shape (6,1)
        Desired task space velocity
    ddXd : np.ndarray of shape (6,1)
        Desired task space acceleration
    Tc : np.ndarray of shape (6,1)
        Command torque
    msg : Float64MultiArray
        Torque message to be published
    D : np.ndarray of shape (6,6)
        Joint Space Inertia Matrix
    CG : np.ndarray of shape (6,1)
        Vector of centrifugal, coriolis and gravity forces
    Bt : np.ndarray of shape (6,1)
        Task to be performed
    qdd : np.ndarray of shape (6,1)
        Commanded joint space acceleration
    V : list
        list of spatial velocities
    A : list
        list of spatial accelerations
    g : list
        list of spatial gravity
    &#34;&#34;&#34;
    
    def __init__(self,Kp=100,Kd=20,f=200):
        &#34;&#34;&#34;
        Parameters
        ----------
        Kp : TYPE, float
             The default is 100.
        Kd : TYPE, float
             The default is 20.
        f : TYPE, float
             The default is 200.Frequency at which to publish torque
        &#34;&#34;&#34;
        
        self.Kp=Kp
        self.Kd=Kd
        self.joint_state=JointState()#stores joint state message
        #setting initial values
        self.joint_state.position=6*[0]
        self.joint_state.velocity=6*[0]
        #joint state subscriber
        self.joint_state_sub=rospy.Subscriber(&#39;/manipulator/joint_states&#39;, JointState, self.update_state,queue_size=1) #subscriber for joint state
        self.theta=np.zeros((6,1))#current joint angle
        self.dtheta=np.zeros((6,1))#current joint velocity
        self.phis=np.zeros((6,6,6))#rigid body transformation matrix
        self.phis_l=np.zeros((6,6,6))#link rigid body transformation matrix
        self.cphis=np.zeros((6,6,6))#cummulative rigid body transformation matrix
        self.task_spatial_pos=np.zeros((6,1))#current task space coordinate
        self.task_spatial_vel=np.zeros((6,1))#current task space velocity
        #for storing jacobians and jacobian derivatives
        self.Ja_=np.zeros((6,6))
        self.Ja_inv=np.zeros((6,6))
        self.Ja=np.zeros((6,6))
        self.Jad=np.zeros((6,6))
        
        self.f=f#torque publishing frequency
        
        #initial desired task space coordinate, task space velocity and task space acceleration
        theta=np.array([[0,pi/3,-pi/2,0,pi/3,0]]).T
        self.Xd=joint2task(theta)
        self.dXd=np.zeros((6,1))
        self.ddXd=np.zeros((6,1))

        self.Tc=np.zeros((6,1))#computed joint torque
        #torque publisher
        self.torque_pub=rospy.Publisher(&#39;/manipulator/group_effort_controller/command&#39;,Float64MultiArray,queue_size=1,latch=True)#command torque publisher
        self.msg=Float64MultiArray()#torque message to be published
        
        #matrices used for command torque computation
        self.D=np.zeros((6,6))
        self.CG=np.zeros((6,1))
        self.Bt=np.zeros((6,1))
        self.qdd=np.zeros((6,1))
        self.V=6*[np.zeros((6,1))]
        self.A=6*[np.zeros((6,1))]
        self.g=6*[np.zeros((6,1))]
        
        #subscriber for desired task space trajectory
        self.traj_sub=rospy.Subscriber(&#39;/task_desired&#39;, Float64MultiArray, self.update_desired_task,queue_size=1) #subscribing to /theta_desired
        

    def update_state(self,msg):
        &#34;&#34;&#34;
        Call back function for joint state subscriber. Updates self.theta and self.thetad whenever a new joint state message is received

        Parameters
        ----------
        msg : JointState
             Message received on /hhumanoid/joint_states

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.joint_state.position=msg.position
        self.joint_state.velocity=msg.velocity
        self.joint_state.header=msg.header
        
    def update_desired_task(self,msg):
        &#34;&#34;&#34;
        Call back function for desired task space trajectory topic. Updates corresponding values 
        for command torque computation

        Parameters
        ----------
        msg : Float64MultiArray
             message within the desired task space trajectory topic

        Returns
        -------
        None.

        &#34;&#34;&#34;
        traj=msg.data
        self.Xd[0:6,0]=traj[0:6]
        self.dXd[0:6,0]=traj[6:12]
        self.ddXd[0:6,0]=traj[12:18]

    def compute_torque(self):
        &#34;&#34;&#34;
        Carries out one iteration of command torque computation.
        
        Takes current joint space position and velocity, uses it to get the rigid 
        body transformation matrices and calculate the Analytical Jacobian and its 
        time derivative. The Jacobian matrix is then regularized and its pseudo-
        inverse is taken.The required task to be performed is then computed, and 
        using the pseudo inverse of the Jacobian, the required joint space acceleration
        is obtained. The command torque is finally obtained by means of inverse 
        dynamics.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        #get current joint state and joint velocity
        self.theta[0:6,0],self.dtheta[0:6,0]=self.joint_state.position[0:6],self.joint_state.velocity[0:6]
        #get rigid body transformation matrices and cumulative rigid body transformation matrices
        self.phis[:,:,:],self.phis_l[:,:,:],_=get_phi(alpha,a,theta0,self.theta,d,a0,alpha0)
        self.cphis[:,:,:]=get_cummulative_phi(self.phis)
        #rigid body transformation from base frame to end effector frame
        ef=self.cphis[0,:,:] @ phi6_ef
        #get current task space coordinate
        self.task_spatial_pos[0:3]=np.array(euler_from_matrix(ef[0:3,0:3],&#39;rzyz&#39;)).reshape((3,1))
        self.task_spatial_pos[3:6]=pos_from_phi(ef)
        euler=self.task_spatial_pos[0:3]#get current euler angle
        Ta_inv=geometric2analytic_jacobian(euler)#matrix to be premultiplied with geometric jacobian
        J,J_,R06=geometric_jacobian(self.cphis)#get geometric jacobian
        self.Ja_[:,:]=np.matmul(Ta_inv,J)#analytical jacobian

        self.Ja[:,:]=self.Ja_[:,:]#to separate from regularized analytical jacobian

        self.task_spatial_vel[:,:]=np.matmul(self.Ja,self.dtheta)#current task space velocity
        Jd=dJ_dt(J_,R06,self.phis,self.phis_l,self.cphis,self.theta,self.dtheta,6)#derivative of geometric jacobian
        deuler=self.task_spatial_vel[0:3]#euler angle rate
        dte=dTe(euler,deuler)
        self.Jad[:,:]=Ta_inv @ (Jd-dte @ self.Ja)#derivative of analytical jacobian
        
        self.Ja_[:,:],self.Ja_inv[:,:]=self.regularize(self.Ja,100)#regularize
        err=self.state_difference(self.Xd,self.task_spatial_pos)#error

        derr=self.dXd-self.task_spatial_vel#derivative error
        #command torque computation
        self.Bt[:,:]=self.ddXd+self.Kd * derr +self.Kp * err-np.matmul(self.Jad,self.dtheta)
        self.qdd[:,:]=self.Ja_inv @ self.Bt+(np.eye(6)-(self.Ja_inv @ self.Ja_)) @ (100-self.theta+20-self.dtheta)
        self.D[:,:]=compute_D(SMs, self.phis,H)
        self.V[:],self.A[:],self.g[:]=forward_sweep(theta0,self.theta,self.dtheta,self.phis,H)
        self.CG[:,:]= reverse_sweep(self.phis,SMs,m,self.V,self.A,self.g,H,COMs)
        self.Tc[:,:]= self.D @ self.qdd +self.CG

    def regularize(self,A,cond):
        &#34;&#34;&#34;
        regularizes input matrix A using a modified truncated SVD regularization using
        cond as the threshold condition number

        Parameters
        ----------
        A : numpy.ndarray
             input matrix
        cond : float
             threshold condition number

        Returns
        -------
        A_ : numpy.ndarray
             regularized matrix
        A_pinv: numpy.ndarray
            pseudo inverse of regularized matrix

        &#34;&#34;&#34;
        U,S,Vt=np.linalg.svd(A)

        S=S[S[0]/S&lt;cond]

        S_=np.diag(S)
        n=len(S)
        A_=np.matmul(U[:,0:n],np.matmul(S_,Vt[0:n,:]))#regularized matrix

        S1=1/S
        S1_=np.diag(S1)
        A_pinv=np.matmul(Vt[0:n,:].T,np.matmul(S1_,U[:,0:n].T))
        return A_,A_pinv


    def state_difference(self,Xg,Xs):
        &#34;&#34;&#34;
        The function which gives the difference between task space coordinates
        Xg and Xs as per the Euler Angle based scheme.

        Parameters
        ----------
        Xg : numpy.ndarray
             goal task space coordinate/desired task space coordinate
        Xs : numpy.ndarray
             start task space coordinate/current task space coordinate

        Returns
        -------
        Xd : numpy.ndarray
             difference between task space coordinates Xg and Xs as per the control scheme.

        &#34;&#34;&#34;
        Xd=Xg-Xs
        Xde=Xd[0:3]
        #converting angles greater than pi to equivalent negative angle
        #done so that the difference indicates the shortest possible path
        idx=np.abs(Xde)&gt;pi
        Xde[idx]=-np.sign(Xde[idx])*(2*pi-np.abs(Xde[idx]))
        Xd[0:3,0]=Xde[0:3,0]
        return Xd

    def control_loop(self):
        &#34;&#34;&#34;
        Carries out one iteration of torque computation, followed by publishing
        the torque to /manipulator/group_effort_controller/command.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        r=rospy.Rate(self.f)

        while not rospy.is_shutdown():
            self.compute_torque()#compute torque
            self.msg.data=self.Tc[:]#message to be published
            try:

                self.torque_pub.publish(self.msg)#publish
                r.sleep()
            except:
                break
    
    def get_time(self):
        &#34;&#34;&#34;
        helper function to get current time from the joint state

        Returns
        -------
        t : float
             current time

        &#34;&#34;&#34;
        header=self.joint_state.header
        t=header.stamp.secs+header.stamp.nsecs*10**-9
        return t</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.task_controller.Task_Controller.compute_torque"><code class="name flex">
<span>def <span class="ident">compute_torque</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out one iteration of command torque computation.</p>
<p>Takes current joint space position and velocity, uses it to get the rigid
body transformation matrices and calculate the Analytical Jacobian and its
time derivative. The Jacobian matrix is then regularized and its pseudo-
inverse is taken.The required task to be performed is then computed, and
using the pseudo inverse of the Jacobian, the required joint space acceleration
is obtained. The command torque is finally obtained by means of inverse
dynamics.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_torque(self):
    &#34;&#34;&#34;
    Carries out one iteration of command torque computation.
    
    Takes current joint space position and velocity, uses it to get the rigid 
    body transformation matrices and calculate the Analytical Jacobian and its 
    time derivative. The Jacobian matrix is then regularized and its pseudo-
    inverse is taken.The required task to be performed is then computed, and 
    using the pseudo inverse of the Jacobian, the required joint space acceleration
    is obtained. The command torque is finally obtained by means of inverse 
    dynamics.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    #get current joint state and joint velocity
    self.theta[0:6,0],self.dtheta[0:6,0]=self.joint_state.position[0:6],self.joint_state.velocity[0:6]
    #get rigid body transformation matrices and cumulative rigid body transformation matrices
    self.phis[:,:,:],self.phis_l[:,:,:],_=get_phi(alpha,a,theta0,self.theta,d,a0,alpha0)
    self.cphis[:,:,:]=get_cummulative_phi(self.phis)
    #rigid body transformation from base frame to end effector frame
    ef=self.cphis[0,:,:] @ phi6_ef
    #get current task space coordinate
    self.task_spatial_pos[0:3]=np.array(euler_from_matrix(ef[0:3,0:3],&#39;rzyz&#39;)).reshape((3,1))
    self.task_spatial_pos[3:6]=pos_from_phi(ef)
    euler=self.task_spatial_pos[0:3]#get current euler angle
    Ta_inv=geometric2analytic_jacobian(euler)#matrix to be premultiplied with geometric jacobian
    J,J_,R06=geometric_jacobian(self.cphis)#get geometric jacobian
    self.Ja_[:,:]=np.matmul(Ta_inv,J)#analytical jacobian

    self.Ja[:,:]=self.Ja_[:,:]#to separate from regularized analytical jacobian

    self.task_spatial_vel[:,:]=np.matmul(self.Ja,self.dtheta)#current task space velocity
    Jd=dJ_dt(J_,R06,self.phis,self.phis_l,self.cphis,self.theta,self.dtheta,6)#derivative of geometric jacobian
    deuler=self.task_spatial_vel[0:3]#euler angle rate
    dte=dTe(euler,deuler)
    self.Jad[:,:]=Ta_inv @ (Jd-dte @ self.Ja)#derivative of analytical jacobian
    
    self.Ja_[:,:],self.Ja_inv[:,:]=self.regularize(self.Ja,100)#regularize
    err=self.state_difference(self.Xd,self.task_spatial_pos)#error

    derr=self.dXd-self.task_spatial_vel#derivative error
    #command torque computation
    self.Bt[:,:]=self.ddXd+self.Kd * derr +self.Kp * err-np.matmul(self.Jad,self.dtheta)
    self.qdd[:,:]=self.Ja_inv @ self.Bt+(np.eye(6)-(self.Ja_inv @ self.Ja_)) @ (100-self.theta+20-self.dtheta)
    self.D[:,:]=compute_D(SMs, self.phis,H)
    self.V[:],self.A[:],self.g[:]=forward_sweep(theta0,self.theta,self.dtheta,self.phis,H)
    self.CG[:,:]= reverse_sweep(self.phis,SMs,m,self.V,self.A,self.g,H,COMs)
    self.Tc[:,:]= self.D @ self.qdd +self.CG</code></pre>
</details>
</dd>
<dt id="src.task_controller.Task_Controller.control_loop"><code class="name flex">
<span>def <span class="ident">control_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out one iteration of torque computation, followed by publishing
the torque to /manipulator/group_effort_controller/command.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def control_loop(self):
    &#34;&#34;&#34;
    Carries out one iteration of torque computation, followed by publishing
    the torque to /manipulator/group_effort_controller/command.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    r=rospy.Rate(self.f)

    while not rospy.is_shutdown():
        self.compute_torque()#compute torque
        self.msg.data=self.Tc[:]#message to be published
        try:

            self.torque_pub.publish(self.msg)#publish
            r.sleep()
        except:
            break</code></pre>
</details>
</dd>
<dt id="src.task_controller.Task_Controller.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>helper function to get current time from the joint state</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>current time</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time(self):
    &#34;&#34;&#34;
    helper function to get current time from the joint state

    Returns
    -------
    t : float
         current time

    &#34;&#34;&#34;
    header=self.joint_state.header
    t=header.stamp.secs+header.stamp.nsecs*10**-9
    return t</code></pre>
</details>
</dd>
<dt id="src.task_controller.Task_Controller.regularize"><code class="name flex">
<span>def <span class="ident">regularize</span></span>(<span>self, A, cond)</span>
</code></dt>
<dd>
<div class="desc"><p>regularizes input matrix A using a modified truncated SVD regularization using
cond as the threshold condition number</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>input matrix</dd>
<dt><strong><code>cond</code></strong> :&ensp;<code>float</code></dt>
<dd>threshold condition number</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>A_</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>regularized matrix</dd>
<dt><strong><code>A_pinv</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>pseudo inverse of regularized matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regularize(self,A,cond):
    &#34;&#34;&#34;
    regularizes input matrix A using a modified truncated SVD regularization using
    cond as the threshold condition number

    Parameters
    ----------
    A : numpy.ndarray
         input matrix
    cond : float
         threshold condition number

    Returns
    -------
    A_ : numpy.ndarray
         regularized matrix
    A_pinv: numpy.ndarray
        pseudo inverse of regularized matrix

    &#34;&#34;&#34;
    U,S,Vt=np.linalg.svd(A)

    S=S[S[0]/S&lt;cond]

    S_=np.diag(S)
    n=len(S)
    A_=np.matmul(U[:,0:n],np.matmul(S_,Vt[0:n,:]))#regularized matrix

    S1=1/S
    S1_=np.diag(S1)
    A_pinv=np.matmul(Vt[0:n,:].T,np.matmul(S1_,U[:,0:n].T))
    return A_,A_pinv</code></pre>
</details>
</dd>
<dt id="src.task_controller.Task_Controller.state_difference"><code class="name flex">
<span>def <span class="ident">state_difference</span></span>(<span>self, Xg, Xs)</span>
</code></dt>
<dd>
<div class="desc"><p>The function which gives the difference between task space coordinates
Xg and Xs as per the Euler Angle based scheme.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Xg</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>goal task space coordinate/desired task space coordinate</dd>
<dt><strong><code>Xs</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>start task space coordinate/current task space coordinate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Xd</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>difference between task space coordinates Xg and Xs as per the control scheme.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def state_difference(self,Xg,Xs):
    &#34;&#34;&#34;
    The function which gives the difference between task space coordinates
    Xg and Xs as per the Euler Angle based scheme.

    Parameters
    ----------
    Xg : numpy.ndarray
         goal task space coordinate/desired task space coordinate
    Xs : numpy.ndarray
         start task space coordinate/current task space coordinate

    Returns
    -------
    Xd : numpy.ndarray
         difference between task space coordinates Xg and Xs as per the control scheme.

    &#34;&#34;&#34;
    Xd=Xg-Xs
    Xde=Xd[0:3]
    #converting angles greater than pi to equivalent negative angle
    #done so that the difference indicates the shortest possible path
    idx=np.abs(Xde)&gt;pi
    Xde[idx]=-np.sign(Xde[idx])*(2*pi-np.abs(Xde[idx]))
    Xd[0:3,0]=Xde[0:3,0]
    return Xd</code></pre>
</details>
</dd>
<dt id="src.task_controller.Task_Controller.update_desired_task"><code class="name flex">
<span>def <span class="ident">update_desired_task</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Call back function for desired task space trajectory topic. Updates corresponding values
for command torque computation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>Float64MultiArray</code></dt>
<dd>message within the desired task space trajectory topic</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_desired_task(self,msg):
    &#34;&#34;&#34;
    Call back function for desired task space trajectory topic. Updates corresponding values 
    for command torque computation

    Parameters
    ----------
    msg : Float64MultiArray
         message within the desired task space trajectory topic

    Returns
    -------
    None.

    &#34;&#34;&#34;
    traj=msg.data
    self.Xd[0:6,0]=traj[0:6]
    self.dXd[0:6,0]=traj[6:12]
    self.ddXd[0:6,0]=traj[12:18]</code></pre>
</details>
</dd>
<dt id="src.task_controller.Task_Controller.update_state"><code class="name flex">
<span>def <span class="ident">update_state</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Call back function for joint state subscriber. Updates self.theta and self.thetad whenever a new joint state message is received</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>JointState</code></dt>
<dd>Message received on /hhumanoid/joint_states</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_state(self,msg):
    &#34;&#34;&#34;
    Call back function for joint state subscriber. Updates self.theta and self.thetad whenever a new joint state message is received

    Parameters
    ----------
    msg : JointState
         Message received on /hhumanoid/joint_states

    Returns
    -------
    None.

    &#34;&#34;&#34;
    self.joint_state.position=msg.position
    self.joint_state.velocity=msg.velocity
    self.joint_state.header=msg.header</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.task_controller.Task_Controller" href="#src.task_controller.Task_Controller">Task_Controller</a></code></h4>
<ul class="two-column">
<li><code><a title="src.task_controller.Task_Controller.compute_torque" href="#src.task_controller.Task_Controller.compute_torque">compute_torque</a></code></li>
<li><code><a title="src.task_controller.Task_Controller.control_loop" href="#src.task_controller.Task_Controller.control_loop">control_loop</a></code></li>
<li><code><a title="src.task_controller.Task_Controller.get_time" href="#src.task_controller.Task_Controller.get_time">get_time</a></code></li>
<li><code><a title="src.task_controller.Task_Controller.regularize" href="#src.task_controller.Task_Controller.regularize">regularize</a></code></li>
<li><code><a title="src.task_controller.Task_Controller.state_difference" href="#src.task_controller.Task_Controller.state_difference">state_difference</a></code></li>
<li><code><a title="src.task_controller.Task_Controller.update_desired_task" href="#src.task_controller.Task_Controller.update_desired_task">update_desired_task</a></code></li>
<li><code><a title="src.task_controller.Task_Controller.update_state" href="#src.task_controller.Task_Controller.update_state">update_state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>