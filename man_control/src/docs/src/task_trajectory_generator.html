<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.task_trajectory_generator API documentation</title>
<meta name="description" content="Created on Sat Jun 12 00:19:46 2021 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.task_trajectory_generator</code></h1>
</header>
<section id="section-intro">
<p>Created on Sat Jun 12 00:19:46 2021</p>
<p>@author: dsubhasish</p>
<p>This is a basic task space trajectory generator which can be used as a template to
create more complex trajectory generators.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Sat Jun 12 00:19:46 2021

@author: dsubhasish

This is a basic task space trajectory generator which can be used as a template to
create more complex trajectory generators.
&#34;&#34;&#34;


import numpy as np
from control_func import joint2task,pi,sin,cos,Rx,Ry,Rz
import rospy
from std_msgs.msg import Float64MultiArray
from visualization_msgs.msg import Marker
from geometry_msgs.msg import Point
from tf.transformations import *
from geometry_msgs.msg import PoseStamped

class Task_Traj_Gen(object):
    &#34;&#34;&#34;
    This class implements a minimal desired task space trajectory generator.
    
    The trajectory generated resembles an infinity symbol. This is achieved by 
    dividing the time period into five segments (straight line, circular arc, 
    straight line, circular arc and straight line), and then computing the 
    trajectory accordingly as per the current time segment. This is then repeated
    by resetting the time period.
    
    Attributes
    ----------
    traj : Float64MultiArray
        The computed trajectory will be transferred to this message type for publishing
    trajd : np.ndarray of shape (18,1)
        Desired trajectory
    trajd : np.ndarray of shape (18,1)
        Starting point for the trajectory
    traj_pub : rospy.Publisher
        Publisher of desired task trajectory topic (/task_desired).
    visualize : bool
        Whether or not additional topics should be published for visualization in RViz
    point_marker : Marker
        RViz visualization marker representing the desired tool tip point
    point_pub : rospy.Publisher
        Publisher for sending desired tool tip point to RViz over the topic /desired_tool_tip
    point_marker1 : Marker
        RViz visualization marker representing the desired tool tip direction
    point_pub1 : rospy.Publisher
        Publisher for sending desired tool tip direction to RViz over the topic /desired_tool_direction
    pose_msg : PoseStamped()
        Message for sending desired tool tip pose. 
    pose_pub : rospy.Publisher
        Publisher for sending desired tool tip pose to RViz over the topic /desired_tool_pose
    &#34;&#34;&#34;
    def __init__(self,visualize=True):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        visualize : TYPE, optional boolean
            DESCRIPTION. The default is True. Is additional visualization required in RViz

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.traj=Float64MultiArray()#desired trajectory message
        #initial desired task trajectory
        theta=np.array([[0,pi/3,-pi/2,0,pi/3,0]]).T
        self.trajd=np.zeros((18,1))
        self.trajd[0:6]=joint2task(theta)
        self.traj0=self.trajd[0:6].copy()
        self.traj_pub=rospy.Publisher(&#39;/task_desired&#39;,Float64MultiArray,queue_size=1,latch=True) #desired trajectory publisher
        self.visualize=visualize
        
        if self.visualize: #if visualization is needed
            #tool_tip point visualizer
            self.point_marker=Marker()
            self.point_marker.header.frame_id = &#34;world&#34;
            self.point_marker.type = self.point_marker.SPHERE_LIST
            self.point_marker.action = self.point_marker.ADD
            # marker scale
            self.point_marker.scale.x = 0.02
            self.point_marker.scale.y = 0.02
            self.point_marker.scale.z = 0.02
            # marker color
            self.point_marker.color.a = 1.0
            self.point_marker.color.r = 1.0
            self.point_marker.color.g = 0.0
            self.point_marker.color.b = 0.5
            # marker orientaiton
            self.point_marker.pose.orientation.x = 0.0
            self.point_marker.pose.orientation.y = 0.0
            self.point_marker.pose.orientation.z = 0.0
            self.point_marker.pose.orientation.w = 1.0
            # marker position
            self.point_marker.pose.position.x = 0.0
            self.point_marker.pose.position.y = 0.0
            self.point_marker.pose.position.z = 0.0
            self.point_marker.points=[]
            self.point_pub=rospy.Publisher(&#39;desired_tool_tip&#39;, Marker, queue_size=1, latch=True)
            
            #tool_tip direction as an arrow
            self.point_marker1=Marker()
            self.point_marker1.header.frame_id = &#34;world&#34;
            self.point_marker1.type = self.point_marker.ARROW
            self.point_marker1.action = self.point_marker.ADD
            # marker scale
            self.point_marker1.scale.x = 0.01
            self.point_marker1.scale.y = 0.01
            self.point_marker1.scale.z = 0.01
            # marker color
            self.point_marker1.color.a = 1.0
            self.point_marker1.color.r = 0.0
            self.point_marker1.color.g = 0.0
            self.point_marker1.color.b = 1.0
            # marker orientaiton
            self.point_marker1.pose.orientation.x = 0.0
            self.point_marker1.pose.orientation.y = 0.0
            self.point_marker1.pose.orientation.z = 0.0
            self.point_marker1.pose.orientation.w = 1.0
            # marker position
            self.point_marker1.pose.position.x = 0.0
            self.point_marker1.pose.position.y = 0.0
            self.point_marker1.pose.position.z = 0.0
            self.point_marker1.points=[]
            self.point_pub1=rospy.Publisher(&#39;desired_tool_direction&#39;, Marker, queue_size=1, latch=True)
            
            #tool_tip pose
            self.pose_msg=PoseStamped()
            self.pose_pub=rospy.Publisher(&#39;desired_tool_pose&#39;, PoseStamped, queue_size=1, latch=True)
            
    def publish_traj(self):
        &#34;&#34;&#34;
        Starts the trajectory computation and publishing loop. Splits the time period into five segments
        and computes the desired trajectory accordingly. The magnitude of velocity and orientation
        is kept constant over the entire desired trajectory. The computed trajectory is then published to
        /task_desired topic.

        Returns
        -------
        None.

        &#34;&#34;&#34;        
        r=rospy.Rate(200)#rate at which to publish
        t0=rospy.get_time()
        rospy.sleep(0.005)
        t0=rospy.get_time()
        if self.visualize:
            #update visualization markers
            R_euler=Rz(self.traj0[0,0]) @ Ry(self.traj0[1,0]) @ Rz(self.traj0[2,0])
            T_euler=np.eye(4)
            T_euler[0:3,0:3]=R_euler
            quat=quaternion_from_matrix(T_euler)
            
            self.pose_msg.header.frame_id=&#34;world&#34;
            self.pose_msg.header.stamp=rospy.Time.now()
            
            self.pose_msg.pose.orientation.x=quat[0]
            self.pose_msg.pose.orientation.y=quat[1]
            self.pose_msg.pose.orientation.z=quat[2]
            self.pose_msg.pose.orientation.w=quat[3]
            
            pt1=Point()
            pt2=Point()
        while not rospy.is_shutdown():
            t_=rospy.get_time()
            t=t_-t0
            #split trajectory to five segments depending on the current time
            #and then use conditionals to compute the trajectory during 
            #these segments
            if t&lt;1:#straight line
                p=t*(R(pi/4) @ np.array([[-0.3,0]]).T)
                dp=R(pi/4) @ np.array([[-0.3,0]]).T*1
                ddp=np.zeros((2,1))
            elif t&gt;=1 and t&lt;1+3*pi/2:#circular arc
                theta0=2*pi-pi/4
                theta=theta0-(t-1)
                p=0.3*np.array([[cos(theta),sin(theta)]]).T+np.array([[-np.sqrt(2)*0.3,0]]).T
                dp=0.3*np.array([[-sin(theta),cos(theta)]]).T*-1
                ddp=0.3*np.array([[-cos(theta),-sin(theta)]]).T*-1*-1
            elif t&gt;=1+3*pi/2 and t&lt;3+3*pi/2:#straight line
                p=np.array([[-0.3/np.sqrt(2),0.3/np.sqrt(2)]]).T+R(-pi/4) @ np.array([[0.3,0]]).T*(t-1-3*pi/2);
                dp=R(-pi/4) @ np.array([[0.3,0]]).T*1
                ddp=np.zeros((2,1))
            elif t&gt;=3+3*pi/2 and t&lt;3+3*pi:#circular arc
                theta0=pi+pi/4
                theta=theta0+(t-3-3*pi/2)
                p=0.3*np.array([[cos(theta),sin(theta)]]).T+np.array([[np.sqrt(2)*0.3,0]]).T
                dp=0.3*np.array([[-sin(theta),cos(theta)]]).T*1
                ddp=0.3*np.array([[-cos(theta),-sin(theta)]]).T*1*1
            elif t&gt;=3+3*pi and t&lt;4+3*pi:#straight line
                p=np.array([[0.3/np.sqrt(2),0.3/np.sqrt(2)]]).T+R(pi/4) @ np.array([[-0.3,0]]).T*(t-3-3*pi);
                dp=R(pi/4) @ np.array([[-0.3,0]]).T*1
                ddp=np.zeros((2,1))
            else:#reset time period
                t0=rospy.get_time()
            #need to be scaled by 0.9 because initial coordinates are out of reach    
            p=0.9*p
            dp=0.9*dp
            ddp=0.9*ddp
            #update desired trajectory message
            self.trajd[4:6,0]=self.traj0[4:6,0]+p[0:2,0]
            self.trajd[10:12,0]=dp[0:2,0]
            self.trajd[16:18,0]=ddp[0:2,0]
            self.traj.data[:]=self.trajd[:]
            if self.visualize:
                #update visualization markers
                pt1.x, pt1.y, pt1.z=self.trajd[3:6,0]
                
                pt2.x, pt2.y, pt2.z=(self.trajd[3:6]+R_euler @ np.array([[0,0,0.2]]).T).squeeze()
                self.point_marker.points=[pt1]
                self.point_marker1.points=[pt1,pt2]
                self.pose_msg.header.stamp=rospy.Time.now()
                self.pose_msg.pose.position.x=self.trajd[3,0]
                self.pose_msg.pose.position.y=self.trajd[4,0]
                self.pose_msg.pose.position.z=self.trajd[5,0]
            try:
                self.traj_pub.publish(self.traj)#oublish desired trajectory
                if self.visualize:
                    #publish visualization markers
                    self.point_pub.publish(self.point_marker)
                    self.point_pub1.publish(self.point_marker1)
                    self.pose_pub.publish(self.pose_msg)
                r.sleep()
            except:
                    break

def R(theta):
    &#34;&#34;&#34;
    two dimensional rotation matrix

    Parameters
    ----------
    theta : TYPE
        DESCRIPTION.

    Returns
    -------
    TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    return np.array([[cos(theta),-sin(theta)],
                      [sin(theta),cos(theta)]])

if __name__==&#34;__main__&#34;:
    rospy.init_node(&#39;task_trajectory_generator&#39;)
    traj_gen=Task_Traj_Gen()
    traj_gen.publish_traj()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.task_trajectory_generator.R"><code class="name flex">
<span>def <span class="ident">R</span></span>(<span>theta)</span>
</code></dt>
<dd>
<div class="desc"><p>two dimensional rotation matrix</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def R(theta):
    &#34;&#34;&#34;
    two dimensional rotation matrix

    Parameters
    ----------
    theta : TYPE
        DESCRIPTION.

    Returns
    -------
    TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    return np.array([[cos(theta),-sin(theta)],
                      [sin(theta),cos(theta)]])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.task_trajectory_generator.Task_Traj_Gen"><code class="flex name class">
<span>class <span class="ident">Task_Traj_Gen</span></span>
<span>(</span><span>visualize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This class implements a minimal desired task space trajectory generator.</p>
<p>The trajectory generated resembles an infinity symbol. This is achieved by
dividing the time period into five segments (straight line, circular arc,
straight line, circular arc and straight line), and then computing the
trajectory accordingly as per the current time segment. This is then repeated
by resetting the time period.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>traj</code></strong> :&ensp;<code>Float64MultiArray</code></dt>
<dd>The computed trajectory will be transferred to this message type for publishing</dd>
<dt><strong><code>trajd</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (18,1)</code></dt>
<dd>Desired trajectory</dd>
<dt><strong><code>trajd</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (18,1)</code></dt>
<dd>Starting point for the trajectory</dd>
<dt><strong><code>traj_pub</code></strong> :&ensp;<code>rospy.Publisher</code></dt>
<dd>Publisher of desired task trajectory topic (/task_desired).</dd>
<dt><strong><code>visualize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not additional topics should be published for visualization in RViz</dd>
<dt><strong><code>point_marker</code></strong> :&ensp;<code>Marker</code></dt>
<dd>RViz visualization marker representing the desired tool tip point</dd>
<dt><strong><code>point_pub</code></strong> :&ensp;<code>rospy.Publisher</code></dt>
<dd>Publisher for sending desired tool tip point to RViz over the topic /desired_tool_tip</dd>
<dt><strong><code>point_marker1</code></strong> :&ensp;<code>Marker</code></dt>
<dd>RViz visualization marker representing the desired tool tip direction</dd>
<dt><strong><code>point_pub1</code></strong> :&ensp;<code>rospy.Publisher</code></dt>
<dd>Publisher for sending desired tool tip direction to RViz over the topic /desired_tool_direction</dd>
<dt><strong><code>pose_msg</code></strong> :&ensp;<code>PoseStamped()</code></dt>
<dd>Message for sending desired tool tip pose.</dd>
<dt><strong><code>pose_pub</code></strong> :&ensp;<code>rospy.Publisher</code></dt>
<dd>Publisher for sending desired tool tip pose to RViz over the topic /desired_tool_pose</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>visualize</code></strong> :&ensp;<code>TYPE</code>, optional <code>boolean</code></dt>
<dd>DESCRIPTION. The default is True. Is additional visualization required in RViz</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Task_Traj_Gen(object):
    &#34;&#34;&#34;
    This class implements a minimal desired task space trajectory generator.
    
    The trajectory generated resembles an infinity symbol. This is achieved by 
    dividing the time period into five segments (straight line, circular arc, 
    straight line, circular arc and straight line), and then computing the 
    trajectory accordingly as per the current time segment. This is then repeated
    by resetting the time period.
    
    Attributes
    ----------
    traj : Float64MultiArray
        The computed trajectory will be transferred to this message type for publishing
    trajd : np.ndarray of shape (18,1)
        Desired trajectory
    trajd : np.ndarray of shape (18,1)
        Starting point for the trajectory
    traj_pub : rospy.Publisher
        Publisher of desired task trajectory topic (/task_desired).
    visualize : bool
        Whether or not additional topics should be published for visualization in RViz
    point_marker : Marker
        RViz visualization marker representing the desired tool tip point
    point_pub : rospy.Publisher
        Publisher for sending desired tool tip point to RViz over the topic /desired_tool_tip
    point_marker1 : Marker
        RViz visualization marker representing the desired tool tip direction
    point_pub1 : rospy.Publisher
        Publisher for sending desired tool tip direction to RViz over the topic /desired_tool_direction
    pose_msg : PoseStamped()
        Message for sending desired tool tip pose. 
    pose_pub : rospy.Publisher
        Publisher for sending desired tool tip pose to RViz over the topic /desired_tool_pose
    &#34;&#34;&#34;
    def __init__(self,visualize=True):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        visualize : TYPE, optional boolean
            DESCRIPTION. The default is True. Is additional visualization required in RViz

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.traj=Float64MultiArray()#desired trajectory message
        #initial desired task trajectory
        theta=np.array([[0,pi/3,-pi/2,0,pi/3,0]]).T
        self.trajd=np.zeros((18,1))
        self.trajd[0:6]=joint2task(theta)
        self.traj0=self.trajd[0:6].copy()
        self.traj_pub=rospy.Publisher(&#39;/task_desired&#39;,Float64MultiArray,queue_size=1,latch=True) #desired trajectory publisher
        self.visualize=visualize
        
        if self.visualize: #if visualization is needed
            #tool_tip point visualizer
            self.point_marker=Marker()
            self.point_marker.header.frame_id = &#34;world&#34;
            self.point_marker.type = self.point_marker.SPHERE_LIST
            self.point_marker.action = self.point_marker.ADD
            # marker scale
            self.point_marker.scale.x = 0.02
            self.point_marker.scale.y = 0.02
            self.point_marker.scale.z = 0.02
            # marker color
            self.point_marker.color.a = 1.0
            self.point_marker.color.r = 1.0
            self.point_marker.color.g = 0.0
            self.point_marker.color.b = 0.5
            # marker orientaiton
            self.point_marker.pose.orientation.x = 0.0
            self.point_marker.pose.orientation.y = 0.0
            self.point_marker.pose.orientation.z = 0.0
            self.point_marker.pose.orientation.w = 1.0
            # marker position
            self.point_marker.pose.position.x = 0.0
            self.point_marker.pose.position.y = 0.0
            self.point_marker.pose.position.z = 0.0
            self.point_marker.points=[]
            self.point_pub=rospy.Publisher(&#39;desired_tool_tip&#39;, Marker, queue_size=1, latch=True)
            
            #tool_tip direction as an arrow
            self.point_marker1=Marker()
            self.point_marker1.header.frame_id = &#34;world&#34;
            self.point_marker1.type = self.point_marker.ARROW
            self.point_marker1.action = self.point_marker.ADD
            # marker scale
            self.point_marker1.scale.x = 0.01
            self.point_marker1.scale.y = 0.01
            self.point_marker1.scale.z = 0.01
            # marker color
            self.point_marker1.color.a = 1.0
            self.point_marker1.color.r = 0.0
            self.point_marker1.color.g = 0.0
            self.point_marker1.color.b = 1.0
            # marker orientaiton
            self.point_marker1.pose.orientation.x = 0.0
            self.point_marker1.pose.orientation.y = 0.0
            self.point_marker1.pose.orientation.z = 0.0
            self.point_marker1.pose.orientation.w = 1.0
            # marker position
            self.point_marker1.pose.position.x = 0.0
            self.point_marker1.pose.position.y = 0.0
            self.point_marker1.pose.position.z = 0.0
            self.point_marker1.points=[]
            self.point_pub1=rospy.Publisher(&#39;desired_tool_direction&#39;, Marker, queue_size=1, latch=True)
            
            #tool_tip pose
            self.pose_msg=PoseStamped()
            self.pose_pub=rospy.Publisher(&#39;desired_tool_pose&#39;, PoseStamped, queue_size=1, latch=True)
            
    def publish_traj(self):
        &#34;&#34;&#34;
        Starts the trajectory computation and publishing loop. Splits the time period into five segments
        and computes the desired trajectory accordingly. The magnitude of velocity and orientation
        is kept constant over the entire desired trajectory. The computed trajectory is then published to
        /task_desired topic.

        Returns
        -------
        None.

        &#34;&#34;&#34;        
        r=rospy.Rate(200)#rate at which to publish
        t0=rospy.get_time()
        rospy.sleep(0.005)
        t0=rospy.get_time()
        if self.visualize:
            #update visualization markers
            R_euler=Rz(self.traj0[0,0]) @ Ry(self.traj0[1,0]) @ Rz(self.traj0[2,0])
            T_euler=np.eye(4)
            T_euler[0:3,0:3]=R_euler
            quat=quaternion_from_matrix(T_euler)
            
            self.pose_msg.header.frame_id=&#34;world&#34;
            self.pose_msg.header.stamp=rospy.Time.now()
            
            self.pose_msg.pose.orientation.x=quat[0]
            self.pose_msg.pose.orientation.y=quat[1]
            self.pose_msg.pose.orientation.z=quat[2]
            self.pose_msg.pose.orientation.w=quat[3]
            
            pt1=Point()
            pt2=Point()
        while not rospy.is_shutdown():
            t_=rospy.get_time()
            t=t_-t0
            #split trajectory to five segments depending on the current time
            #and then use conditionals to compute the trajectory during 
            #these segments
            if t&lt;1:#straight line
                p=t*(R(pi/4) @ np.array([[-0.3,0]]).T)
                dp=R(pi/4) @ np.array([[-0.3,0]]).T*1
                ddp=np.zeros((2,1))
            elif t&gt;=1 and t&lt;1+3*pi/2:#circular arc
                theta0=2*pi-pi/4
                theta=theta0-(t-1)
                p=0.3*np.array([[cos(theta),sin(theta)]]).T+np.array([[-np.sqrt(2)*0.3,0]]).T
                dp=0.3*np.array([[-sin(theta),cos(theta)]]).T*-1
                ddp=0.3*np.array([[-cos(theta),-sin(theta)]]).T*-1*-1
            elif t&gt;=1+3*pi/2 and t&lt;3+3*pi/2:#straight line
                p=np.array([[-0.3/np.sqrt(2),0.3/np.sqrt(2)]]).T+R(-pi/4) @ np.array([[0.3,0]]).T*(t-1-3*pi/2);
                dp=R(-pi/4) @ np.array([[0.3,0]]).T*1
                ddp=np.zeros((2,1))
            elif t&gt;=3+3*pi/2 and t&lt;3+3*pi:#circular arc
                theta0=pi+pi/4
                theta=theta0+(t-3-3*pi/2)
                p=0.3*np.array([[cos(theta),sin(theta)]]).T+np.array([[np.sqrt(2)*0.3,0]]).T
                dp=0.3*np.array([[-sin(theta),cos(theta)]]).T*1
                ddp=0.3*np.array([[-cos(theta),-sin(theta)]]).T*1*1
            elif t&gt;=3+3*pi and t&lt;4+3*pi:#straight line
                p=np.array([[0.3/np.sqrt(2),0.3/np.sqrt(2)]]).T+R(pi/4) @ np.array([[-0.3,0]]).T*(t-3-3*pi);
                dp=R(pi/4) @ np.array([[-0.3,0]]).T*1
                ddp=np.zeros((2,1))
            else:#reset time period
                t0=rospy.get_time()
            #need to be scaled by 0.9 because initial coordinates are out of reach    
            p=0.9*p
            dp=0.9*dp
            ddp=0.9*ddp
            #update desired trajectory message
            self.trajd[4:6,0]=self.traj0[4:6,0]+p[0:2,0]
            self.trajd[10:12,0]=dp[0:2,0]
            self.trajd[16:18,0]=ddp[0:2,0]
            self.traj.data[:]=self.trajd[:]
            if self.visualize:
                #update visualization markers
                pt1.x, pt1.y, pt1.z=self.trajd[3:6,0]
                
                pt2.x, pt2.y, pt2.z=(self.trajd[3:6]+R_euler @ np.array([[0,0,0.2]]).T).squeeze()
                self.point_marker.points=[pt1]
                self.point_marker1.points=[pt1,pt2]
                self.pose_msg.header.stamp=rospy.Time.now()
                self.pose_msg.pose.position.x=self.trajd[3,0]
                self.pose_msg.pose.position.y=self.trajd[4,0]
                self.pose_msg.pose.position.z=self.trajd[5,0]
            try:
                self.traj_pub.publish(self.traj)#oublish desired trajectory
                if self.visualize:
                    #publish visualization markers
                    self.point_pub.publish(self.point_marker)
                    self.point_pub1.publish(self.point_marker1)
                    self.pose_pub.publish(self.pose_msg)
                r.sleep()
            except:
                    break</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.task_trajectory_generator.Task_Traj_Gen.publish_traj"><code class="name flex">
<span>def <span class="ident">publish_traj</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the trajectory computation and publishing loop. Splits the time period into five segments
and computes the desired trajectory accordingly. The magnitude of velocity and orientation
is kept constant over the entire desired trajectory. The computed trajectory is then published to
/task_desired topic.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def publish_traj(self):
    &#34;&#34;&#34;
    Starts the trajectory computation and publishing loop. Splits the time period into five segments
    and computes the desired trajectory accordingly. The magnitude of velocity and orientation
    is kept constant over the entire desired trajectory. The computed trajectory is then published to
    /task_desired topic.

    Returns
    -------
    None.

    &#34;&#34;&#34;        
    r=rospy.Rate(200)#rate at which to publish
    t0=rospy.get_time()
    rospy.sleep(0.005)
    t0=rospy.get_time()
    if self.visualize:
        #update visualization markers
        R_euler=Rz(self.traj0[0,0]) @ Ry(self.traj0[1,0]) @ Rz(self.traj0[2,0])
        T_euler=np.eye(4)
        T_euler[0:3,0:3]=R_euler
        quat=quaternion_from_matrix(T_euler)
        
        self.pose_msg.header.frame_id=&#34;world&#34;
        self.pose_msg.header.stamp=rospy.Time.now()
        
        self.pose_msg.pose.orientation.x=quat[0]
        self.pose_msg.pose.orientation.y=quat[1]
        self.pose_msg.pose.orientation.z=quat[2]
        self.pose_msg.pose.orientation.w=quat[3]
        
        pt1=Point()
        pt2=Point()
    while not rospy.is_shutdown():
        t_=rospy.get_time()
        t=t_-t0
        #split trajectory to five segments depending on the current time
        #and then use conditionals to compute the trajectory during 
        #these segments
        if t&lt;1:#straight line
            p=t*(R(pi/4) @ np.array([[-0.3,0]]).T)
            dp=R(pi/4) @ np.array([[-0.3,0]]).T*1
            ddp=np.zeros((2,1))
        elif t&gt;=1 and t&lt;1+3*pi/2:#circular arc
            theta0=2*pi-pi/4
            theta=theta0-(t-1)
            p=0.3*np.array([[cos(theta),sin(theta)]]).T+np.array([[-np.sqrt(2)*0.3,0]]).T
            dp=0.3*np.array([[-sin(theta),cos(theta)]]).T*-1
            ddp=0.3*np.array([[-cos(theta),-sin(theta)]]).T*-1*-1
        elif t&gt;=1+3*pi/2 and t&lt;3+3*pi/2:#straight line
            p=np.array([[-0.3/np.sqrt(2),0.3/np.sqrt(2)]]).T+R(-pi/4) @ np.array([[0.3,0]]).T*(t-1-3*pi/2);
            dp=R(-pi/4) @ np.array([[0.3,0]]).T*1
            ddp=np.zeros((2,1))
        elif t&gt;=3+3*pi/2 and t&lt;3+3*pi:#circular arc
            theta0=pi+pi/4
            theta=theta0+(t-3-3*pi/2)
            p=0.3*np.array([[cos(theta),sin(theta)]]).T+np.array([[np.sqrt(2)*0.3,0]]).T
            dp=0.3*np.array([[-sin(theta),cos(theta)]]).T*1
            ddp=0.3*np.array([[-cos(theta),-sin(theta)]]).T*1*1
        elif t&gt;=3+3*pi and t&lt;4+3*pi:#straight line
            p=np.array([[0.3/np.sqrt(2),0.3/np.sqrt(2)]]).T+R(pi/4) @ np.array([[-0.3,0]]).T*(t-3-3*pi);
            dp=R(pi/4) @ np.array([[-0.3,0]]).T*1
            ddp=np.zeros((2,1))
        else:#reset time period
            t0=rospy.get_time()
        #need to be scaled by 0.9 because initial coordinates are out of reach    
        p=0.9*p
        dp=0.9*dp
        ddp=0.9*ddp
        #update desired trajectory message
        self.trajd[4:6,0]=self.traj0[4:6,0]+p[0:2,0]
        self.trajd[10:12,0]=dp[0:2,0]
        self.trajd[16:18,0]=ddp[0:2,0]
        self.traj.data[:]=self.trajd[:]
        if self.visualize:
            #update visualization markers
            pt1.x, pt1.y, pt1.z=self.trajd[3:6,0]
            
            pt2.x, pt2.y, pt2.z=(self.trajd[3:6]+R_euler @ np.array([[0,0,0.2]]).T).squeeze()
            self.point_marker.points=[pt1]
            self.point_marker1.points=[pt1,pt2]
            self.pose_msg.header.stamp=rospy.Time.now()
            self.pose_msg.pose.position.x=self.trajd[3,0]
            self.pose_msg.pose.position.y=self.trajd[4,0]
            self.pose_msg.pose.position.z=self.trajd[5,0]
        try:
            self.traj_pub.publish(self.traj)#oublish desired trajectory
            if self.visualize:
                #publish visualization markers
                self.point_pub.publish(self.point_marker)
                self.point_pub1.publish(self.point_marker1)
                self.pose_pub.publish(self.pose_msg)
            r.sleep()
        except:
                break</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.task_trajectory_generator.R" href="#src.task_trajectory_generator.R">R</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.task_trajectory_generator.Task_Traj_Gen" href="#src.task_trajectory_generator.Task_Traj_Gen">Task_Traj_Gen</a></code></h4>
<ul class="">
<li><code><a title="src.task_trajectory_generator.Task_Traj_Gen.publish_traj" href="#src.task_trajectory_generator.Task_Traj_Gen.publish_traj">publish_traj</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>